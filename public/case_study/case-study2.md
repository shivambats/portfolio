---
title: Replacing Stripe with a Secure, Scalable, and Cost-Efficient Card Tokenization System Using AWS
type: Case Study
year: 2025
tags: [Payments, Stripe, Migrations]
image: /case_study/case-study2.jpg
excerpt: Our platform originally relied on Stripe to manage card payments and tokenization. Stripe offered an excellent developer experience and rapid integration capabilities, which allowed us to go to market quickly. However, as we scaled, we encountered challenges related to cost, flexibility, and control over sensitive data.

---

## **Overview**

Our platform originally relied on Stripe to manage card payments and tokenization. Stripe offered an excellent developer experience and rapid integration capabilities, which allowed us to go to market quickly. However, as we scaled, we encountered challenges related to cost, flexibility, and control over sensitive data.

We decided to migrate from Stripe's managed tokenization services and build our own **card tokenization system** using **AWS Payment Cryptography**. The aim was to securely collect, tokenize, and store cardholder data, reduce long-term operational costs, maintain strict PCI DSS compliance, and have complete control over the cryptographic processes and tokens. All of this had to be done without impacting user experience or compromising on security, even for a second.

---

## **Opportunity**

Stripe was instrumental during our growth phase. It allowed our team to integrate card payments without worrying about PCI compliance or data encryption. However, as our transaction volumes increased, we began noticing a few pain points:

From a **business standpoint**, Stripe's pricing structure began to add up. Every card tokenization and transaction incurred platform-specific charges. With high monthly volumes, these fees became a significant cost center.

From a **product and engineering perspective**, we had minimal visibility into or control over the tokens generated by Stripe. The data resided entirely in Stripe's infrastructure, and this restricted our ability to optimize payment routing, build region-specific workflows, or deeply integrate card tokens with our internal systems.

Additionally, Stripe was a centralized dependency, and our architecture demanded **low-latency**, **multi-region** support. Having a single point of tokenization added friction in delivering a consistent and performant user experience globally.

We needed to:

‚Ä¢ Lower our card-handling and transaction costs
‚Ä¢ Retain full ownership of card token lifecycle management
‚Ä¢ Build a region-aware, secure tokenization pipeline
‚Ä¢ Remain PCI compliant and audit-ready

---

## **Solution**

To address these challenges, we designed and implemented an in-house card tokenization system using **AWS-native services**, primarily **AWS Payment Cryptography**, **DynamoDB**, **KMS**, and **API Gateway + Lambda** for secure compute and access control.

![diagram-export-23-05-2025-09_41_53.png](/case_study/case-study2.jpg)

### **Gathering Requirements**

The first step was an intensive collaboration between product, engineering, and infosec teams to define the security model, technical flows, regulatory boundaries, and key metrics for success.

Some key questions we tackled early:

‚Ä¢ Can we guarantee zero storage of raw card numbers or CVV?
‚Ä¢ How will PCI DSS scope be reduced or shifted?
‚Ä¢ What APIs do internal teams need for payment processing?
‚Ä¢ Can we achieve cross-region support for tokenization and de-tokenization?

We developed threat models, compliance diagrams, and data flow specifications upfront to ensure a fail-safe system.

### **Tokenization and Secure Storage**

We chose **AWS Payment Cryptography** for its out-of-the-box support for secure cryptographic operations including Format-Preserving Encryption (FPE), HSM-backed key management, and PCI PIN security.

Card data was captured on the frontend and sent via HTTPS (TLS 1.2 or higher) to our backend services. Upon receipt:

‚Ä¢ PAN (card number) and expiry were tokenized using AWS Payment Cryptography.
‚Ä¢ CVV was never stored or logged, complying with PCI DSS requirements.
‚Ä¢ The encrypted tokens were stored in **Amazon DynamoDB** with additional encryption-at-rest using **AWS KMS**.
‚Ä¢ The full token object was tagged and versioned, enabling safe lifecycle management.

The internal APIs exposed for reading and writing tokenized card data were built on **API Gateway + AWS Lambda**. All endpoints were protected with IAM roles, scoped auth tokens, and strict access controls. Every operation was logged using **AWS CloudTrail** and **CloudWatch**, with alerting wired into our SIEM pipeline.

### **Migration from Stripe**

Migrating from Stripe required careful planning. We adopted a **phased rollout** strategy:

1. Continued to support existing Stripe tokens while building the new AWS system in parallel.
2. Routed new card entries to the AWS-based tokenization pipeline.
3. Gradually migrated eligible users and transactions to the new system.
4. Ensured backward compatibility by abstracting the tokenization layer behind a unified internal API.

We validated tokens across both systems during early transactions to ensure data fidelity and encryption parity.

## **üåç Inter-region Strategy**

To support low latency across regions like **US-East (N. Virginia)** and **AP-South (Mumbai)**:

‚Ä¢ **DynamoDB Global Tables** were used to replicate tokenized data across regions.
‚Ä¢ **API Gateway and Lambda** are deployed regionally behind a latency-based routing policy using **Route 53**.

### **Region-Specific Key Management**

AWS Payment Cryptography and KMS keys are region-scoped by design, meaning:

‚Ä¢ Each region has its **own set of cryptographic keys**.
‚Ä¢ Card data is tokenized in the **region of ingestion** using **region-specific keys**.
‚Ä¢ Tokens are **valid within the region** but can be resolved using the same algorithm if the key hierarchy is managed consistently.
‚Ä¢ This prevents key leakage and avoids cross-region key replication, aligning with PCI best practices.

This model provides **fault isolation**, **reduces compliance scope**, and maintains **performance parity** across geographies.

### **Regional Latency Optimization**

Since our users span North America, Europe, and APAC, we had to ensure consistent performance.

To minimize inter-region latency:

‚Ä¢ We deployed our tokenization stack in **multiple AWS regions**.
‚Ä¢ Used **Amazon Route 53 latency-based routing** to direct users to the nearest tokenization endpoint.
‚Ä¢ DynamoDB Global Tables were used to replicate token data where required, while keeping compliance constraints in mind.

### **Security and Cost Optimization**

Security was baked into every layer. All services were serverless or HSM-integrated, significantly reducing the operational surface area. Access to raw PAN data was never granted to any user or internal service. Even our developers could not access tokenized card data without explicit temporary credentials.

Cost-wise, by using a pay-per-use model and eliminating per-token fees from Stripe, we reduced payment-related costs dramatically. There was no compromise on compliance or infrastructure hardening.

---

## **Results**

‚Ä¢ **60% cost savings** in monthly payment infrastructure costs by replacing Stripe fees with usage-based AWS pricing
‚Ä¢ **Full PCI DSS compliance** achieved without storing sensitive raw data
‚Ä¢ **Multi-region availability** ensured sub-150ms tokenization times globally
‚Ä¢ **Full control** over card tokens allowed deeper product integrations and analytics
‚Ä¢ **Zero security incidents** with continuous monitoring and encryption
‚Ä¢ **Seamless migration** with no downtime and full compatibility during the transition phase